import fs from 'node:fs';
import path from 'node:path';
import Waves from '../components/Code.js';
import Config from '../components/Config.js';
import Render from '../components/Render.js';
import { pluginResources } from '../model/path.js';

export class Slash extends plugin {
    constructor() {
        super({
            name: '鸣潮-冥歌海墟',
            dsc: '鸣潮-冥歌海墟',
            event: 'message',
            priority: 1009,
            rule: [{
                reg: '^(～|~|∽∽|#?鸣潮)(冥歌海墟|新深渊|(?:再生)?海域|海墟|冥海|破船|禁忌海域|(?:再生海域-?)?海隙|(?:再生海域-?)?湍渊|(?:再生海域-?)?无尽)(\\d{9})?$',
                fnc: 'slash'
            }]
        })
    }

    async slash(e) {
        const userId = e.at || e.user_id;
        let accountList = JSON.parse(await redis.get(`Yunzai:waves:users:${userId}`)) || await Config.getUserConfig(userId);
        const waves = new Waves();

        let [, , type, roleId] = e.msg.match(this.rule[0].reg);

        // 处理无账号但有指定UID的情况
        if (!accountList?.length && roleId) {
            let publicCookie = await waves.pubCookie();
            if (!publicCookie) {
                return e.reply('当前没有可用的公共Cookie, 请使用 [~登录] 进行登录', true);
            }
            publicCookie.roleId = roleId.trim();
            await redis.set(`Yunzai:waves:bind:${userId}`, publicCookie.roleId);
            accountList = [publicCookie];
        } 
        // 处理无账号且无UID的情况
        else if (!accountList?.length) {
            return e.reply('当前没有登录任何账号, 请使用 [~登录] 进行登录', true);
        }

        const data = [];
        const deleteRoleIds = [];

        for (const account of accountList) {
            const currentRoleId = roleId || account.roleId;
            const serverId = account.serverId;
            const token = account.token;

            // 检查token可用性
            const usable = await waves.isAvailable(serverId, currentRoleId, token);
            if (!usable) {
                deleteRoleIds.push(currentRoleId);
                data.push(`账号 ${currentRoleId} 的Token已失效\n请重新使用 [~登录] 进行登录`);
                continue;
            }

            // 如果指定了roleId，更新绑定
            if (roleId) {
                await redis.set(`Yunzai:waves:bind:${userId}`, currentRoleId);
            }

            try {
                // 获取基础数据和海虚数据
                const [baseData, slashData] = await Promise.all([
                    waves.getBaseData(serverId, currentRoleId, token),
                    waves.getHaiXuData(serverId, currentRoleId, token)
                ]);

                if (!baseData.status || !slashData.status) {
                    data.push(baseData.msg || slashData.msg);
                    continue;
                }

                // 格式化数据
                const renderData = await this.formatData(slashData.data, baseData.data, type, e, !!roleId);

                // 渲染图像
                const image = await Render.render('Template/slash/slash', renderData, {
                    e, 
                    retType: 'base64',
                    copyright: `数据来源: 库街区 · 生成时间: ${new Date().toLocaleString()}`
                });

                // 如果指定了roleId，直接返回单个结果
                if (roleId) {
                    return e.reply(image, true);
                }

                data.push(image);
                await new Promise(resolve => setTimeout(resolve, 1000));

            } catch (err) {
                logger.error('[冥歌海墟查询异常]', err);
                data.push(`账号 ${currentRoleId} 查询异常，请稍后重试`);
            }
        }

        // 清理失效账号
        if (deleteRoleIds.length) {
            let newAccountList = accountList.filter(acc => !deleteRoleIds.includes(acc.roleId));
            Config.setUserConfig(userId, newAccountList);
        }

        // 返回结果
        if (data.length === 1) {
            return e.reply(data[0], true);
        } else if (data.length > 1) {
            return e.reply(await e.runtime.common.makeForwardMsg(e, [`用户 ${userId} 的冥歌海墟查询结果`, ...data]));
        }
        
        return e.reply('没有获取到有效的冥歌海墟数据');
    }

    /**
     * 格式化数据
     * @param {Object} slashData - 海虚数据
     * @param {Object} baseData - 基础数据
     * @param {string} type - 类型
     * @param {Object} e - 消息对象
     * @param {boolean} isOther - 是否是其他账号
     * @returns {Object} 渲染数据
     */
    async formatData(slashData, baseData, type, e, isOther) {
        const userInfo = {
            name: baseData.name,
            uid: baseData.id,
            avatar: isOther 
                ? 'https://prod-alicdn-community.kurobbs.com/newHead/offical/mingchao.png'
                : await this.getAvatarUrl(e)
        };

        // 添加难度名称映射
        const difficultyNames = {
            0: '禁忌海域',
            1: '再生海域-海隙',
            2: '再生海域-湍渊'
        };

        // 处理挑战列表数据
        const list = slashData.difficultyList.map(diff => {
            diff.difficultyName = difficultyNames[diff.difficulty] || `难度${diff.difficulty}`;
            const perMaxScore = Math.floor(diff.maxScore / diff.challengeList.length);
            
            return diff.challengeList.map(challenge => ({
                ...challenge,
                maxScore: perMaxScore,
                difficulty: diff.difficulty,
                difficultyName: diff.difficultyName,
                detailPageBG: diff.detailPageBG,
                homePageBG: diff.homePageBG,
                teamIcon: diff.teamIcon
            }));
        });

        const challengeList = this.getPickList(type, list.flat());

        // 计算剩余时间
        const timeDays = Math.floor(slashData.seasonEndTime / 1000 / (3600 * 24));
        const leftTime = timeDays >= 1 ? `${timeDays}天` : '不足1天';

        // 计算总分
        const allScore = challengeList.reduce((acc, item) => acc + item.score, 0);
        const maxScore = challengeList.reduce((acc, item) => acc + item.maxScore, 0);

        return { userInfo, challengeList, leftTime, allScore, maxScore };
    }

    /**
     * 获取选中的挑战列表
     * @param {string} type - 类型
     * @param {Array} challengeList - 挑战列表
     * @returns {Array} 筛选后的挑战列表
     */
    getPickList(type, challengeList) {
        switch (type) {
            case '禁忌海域':
                return challengeList
                    .filter(item => item.difficulty === 0)
                    .sort((a, b) => a.challengeId - b.challengeId);
            case '海隙':
            case '再生海域海隙':
            case '再生海域-海隙':
                return challengeList
                    .filter(item => item.difficulty === 1)
                    .sort((a, b) => a.challengeId - b.challengeId);
            case '湍渊':
            case '无尽':
            case '再生海域湍渊':
            case '再生海域无尽':
            case '再生海域-湍渊':
            case '再生海域-无尽':
                return challengeList
                    .filter(item => item.difficulty === 2)
                    .sort((a, b) => a.challengeId - b.challengeId);
            case '海域':
            case '再生海域':
                return challengeList
                    .filter(item => item.difficulty !== 0)
                    .sort((a, b) => a.challengeId - b.challengeId);
            case '冥歌海墟':
            case '新深渊':
            case '冥海':
            case '破船':
            case '海墟':
            default:
                return challengeList
                    .sort((a, b) => b.challengeId - a.challengeId)
                    .slice(0, 4);
        }
    }

    /**
     * 获取头像URL
     * @param {Object} e - 消息对象
     * @returns {string} 头像URL
     */
    async getAvatarUrl(e) {
        try {
            if (e.isGroup) {
                return await e.group.pickMember(e.user_id).getAvatarUrl();
            }
            return await e.friend.getAvatarUrl();
        } catch {
            return 'https://prod-alicdn-community.kurobbs.com/newHead/offical/mingchao.png';
        }
    }
}
